
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "weka"
%%% End: 
\section{OLAP}
\subsection{OLAP相关概念}
Mondrian是一个基于Java语言的开源OLAP引擎，它通过MDX语句执行查询，从关系型数据库RDBMS中读取数据，以多维度的形式展示查询结果。
\par Mondrian通过Schema来定义一个多维数据库，它是一个逻辑概念上的模型，其中包含Cube（立方体）、Dimension（维度）、Hierarchy（层次）、Level（级别）、Measure（度量），这些被映射到数据库物理模型。Mondrian中Schema是以XML文件的形式定义的。
\begin{itemize}
\item Cube（立方体）是一系列Dimension和Measure的集合区域，它们共用一个事实表。
\item Dimension（维度）是一个Hierarchy的集合，维度一般有其相对应的维度表，它由Hierarchy（层次）组成，而Hierarchy（层次）又是由组成Level（级别）的。
\item Hierarchy（层次）是指定维度的层级关系的，如果没有指定，默认Hierarchy里面装的是来自立方体中的真实表。
\item Level（级别）是Hierarchy的组成部分，使用它可以构成一个结构树，Level的先后顺序决定了Level在结构树上的位置，最顶层的 Level 位于树的第一级，依次类推。
\item Measure（度量）是我们要进行度量计算的数值，支持的操作有sum、count、avg、distinct-count、max、min等。
\end{itemize}
\par 概括总结一下：在多维分析中，关注的内容通常被称为度量(Measure)，而把限制条件称为维度(Dimension)。多维分析就是对同时满足多种限制条件的所有度量值做汇总统计。包含度量值的表被称为事实表(Fact Table)，描述维度具体信息的表被称为维表(Dimension Table)，同时有一点需要注意：并不是所有的维度都要有维表，对于取值简单的维度，可以直接使用事实表中的一列作为维度展示。
\par 下面是Mondrian中一个简单的Schema文件,其中包含一个名为“Sales”的Cube，立方体中有两个维度：“Gender”和“Time”，两个度量值：“Unit Sales”和“Store Sales”。
\begin{verbatim}
<Schema>
<Cube name="Sales">
<Table name="sales_fact_1997"/>
<Dimension name="Gender" foreignKey="customer_id">
<Hierarchy hasAll="true" allMemberName="All Genders" primaryKey="customer_id">
<Table name="customer"/>
<Level name="Gender" column="gender" uniqueMembers="true"/>
</Hierarchy>
</Dimension>
<Dimension name="Time" foreignKey="time_id">
<Hierarchy hasAll="false" primaryKey="time_id">
<Table name="time_by_day"/>
<Level name="Year" column="the_year" type="Numeric" uniqueMembers="true"/>
<Level name="Quarter" column="quarter" uniqueMembers="false"/>
<Level name="Month" column="month_of_year" type="Numeric" uniqueMembers="false"/>
</Hierarchy>
</Dimension>
<Measure name="Unit Sales" column="unit_sales" aggregator="sum" formatString="#,###"/>
<Measure name="Store Sales" column="store_sales" aggregator="sum" formatString="#,###.##"/>
<Measure name="Store Cost" column="store_cost" aggregator="sum" formatString="#,###.00"/>
<CalculatedMember name="Profit" dimension="Measures" formula="[Measures].[Store Sales] - [Measures].[Store Cost]">
<CalculatedMemberProperty name="FORMAT_STRING" value="$#,##0.00"/>
</CalculatedMember>
</Cube>
</Schema>
\end{verbatim}
\subsection{数据预处理}
\par 不正确，不完整和不一致的数据是商场中数据的普遍特点，如许多数据库表元组在某些属性上根本没有值，有些期望获得的属性没有被记录，对同一款商品，不同商场的命名不一样。当用户不希望暴露个人信息的时候，可能故意输入不正确的生日日期。对一个大型商场而言，某个用户的家庭住址可能早就过期了，但针对不同的数据挖掘任务，其满意度也不同，销售人员不太满意，但市场分析人员对这个家庭住址就不太看重。
\begin{itemize}
\item 数据清理用来清除数据中的噪声，纠正不一致。数据清理通过填写缺失的值，光滑噪声数据，识别或删除离群点，也就是清除脏数据的过程，脏数据可能会使某些挖掘算法陷入混乱，导致不可靠的输出。ETL（Etractrion,Transform，Loading）工具允许用户说明简单的变换，如将字符串“列宁格勒”用“圣彼得堡”代替。
\item 数据集成将数据由多个数据源合并成一个一致的数据存储，如数据仓库。代表同一概念的属性在不同的数据库中可能具有不同的名字，关于顾客标识的属性在一个商场数据库中是\textsl{customer\_id},而在另一个数据库中为\textsl{cust\_id},命名的不一致还可能出现在属性值中，例如，方便面在第一个数据库中登记为\textbf{方便面}，在第二个数据库中登记为\textbf{泡面}，在第三个数据库中登记为\textbf{速食面}，某些属性值可能是由其它属性值导出的，例如选修某课程的人数。
\item 数据归约可以通过聚集，删除冗余特征或者聚类方法来降低数据的规模，得到数据的简化表示，小很多，但能产生同样的分析结果。经常用的方法有：小波变换，主成分分析，属性子集选择（去掉不相关的属性）和属性构造（从原来的属性集中生成更有用的小属性集），使用参数模型（回归和对数线性模型）或非参数模型（直方图，聚类，抽样）等。
\item 数据变换可以用来把数据压缩到较小的空间，如0.0到1.0，可以提高涉及距离度量的挖掘算法的准确率和效率。例如，涉及诸如神经网络，最近邻分类或聚类这样的基于距离的挖掘算法。对不同的属性，例如年龄和年薪，年薪的取值范围远远大于年龄，因此，属性值必须规范化。同样的，数据必须进行概念分层，属性的原始值被区间或更高层的概念取代，年龄的原始值可以用较高层的概念（如少年，青年，壮年，老年）取代。
\end{itemize}
\subsection{数据变换与数据离散化}
\par 数据必须变换成统一格式，使得数据挖掘过程更加有效，数据变换策略包括如下几种：
\begin{enumerate}[(1)]
\item 光滑，去掉数据中的噪音，包括分箱，回归和聚类，
\item 属性构造，可以由给定的属性构造出新的属性，并添加到属性集中，
\item 聚集，对数据进行汇总，例如，可以聚集日销售数据，计算每月和每年的销售量，这一步用来为多个抽象层的数据分析构造数据立方体。
\item 规范化，把属性数据按比例缩放，使其落入一个特定的小区间，如$[-1.0 \sim 1.0]$内
\item 离散化：数值属性的原始值（例如年龄）用区间标签（例如，$[0 \sim 10]$，$[11 \sim 20]$，$\cdots$）或概念标签（\textbf{年轻}，\textbf{成熟}，\textbf{老者}）代替，这些概念标签能进一步组成概念分层，即属性的扩展。
\item 由标称数据产生概念分层：属性，如\bfseries{街道}，可以泛化到较高的概念层，如\textbf{城市}，\textbf{省份}等
\end{enumerate}
\par 不正确，不完整和不一致的数据是商场中数据的普遍特点，如许多数据库表元组在某些属性上根本没有值，有些属性没有被记录，对同一款商品，不同商场的命名不一样。